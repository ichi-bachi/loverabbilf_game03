<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>とことこっらびるふ</title>
<style>
  body { margin:0; overflow:hidden; font-family:sans-serif; background:#87ceeb;}
  canvas { display:block; }
  #ui { position:absolute; top:10px; left:10px; color:#fff; font-size:20px; text-shadow:2px 2px 2px #000; }
  #startScreen, #gameOverScreen {
    position:absolute; top:0; left:0; right:0; bottom:0;
    background:rgba(0,0,0,0.6); display:flex; flex-direction:column; justify-content:center; align-items:center;
    color:#fff; font-size:28px; text-align:center;
  }
  button { margin:10px; padding:10px 20px; font-size:20px; border:none; border-radius:8px; cursor:pointer; }
  #pauseBtn { position:absolute; top:10px; right:10px; }
  #rotateNotice {
    position:fixed; top:0; left:0; width:100%; height:100%;
    background:#000; color:#fff; display:none;
    justify-content:center; align-items:center; font-size:2em; z-index:9999;
    text-align:center;
  }
</style>
</head>
<body>
<audio id="bgm" src="bgm.mp3" loop></audio>
<canvas id="gameCanvas"></canvas>
<div id="ui">SCORE: <span id="score">0</span></div>
<button id="pauseBtn">PAUSE</button>
<div id="startScreen">
  <h1>とことこっらびるふ</h1>
  <p>らびるふを操作して障害物をよけながら進もう！<br>
     PC: ↑↓←→ / W/A/S/D で移動<br>
     スマホ: 画面の上下左右タップで移動（横画面推奨）</p>
  <button id="startBtn">START</button>
</div>
<div id="gameOverScreen" style="display:none;">
  <h1>GAME OVER</h1>
  <p id="hiscoreText">HI SCORE: 0</p>
  <button id="retryBtn">RETRY</button>
</div>
<div id="rotateNotice">横画面でプレイしてください</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const bgm = document.getElementById("bgm");

let playerX, playerY;
let playerFrame = 0;
let playerTimer = 0;
let playerSize;
let moveStep;

// 背景
const bgImgs = ["haikei1.png","haikei2.png","haikei3.png"].map(src=>{ let img=new Image(); img.src=src; return img; });
let bgX = 0;

// プレイヤー
const rabbilfFrames = ["rabbilf1.png","rabbilf2.png"].map(src=>{let i=new Image();i.src=src;return i;});

// 敵
const enemyImgs = ["teki1.png","teki2.png","teki3.png"].map(src=>{let i=new Image();i.src=src;return i;});
let enemies = [];
let enemyTimer = 0;

// ゲーム管理
let score=0;
let hiscore=localStorage.getItem("hiscore")||0;
let gameOver=false;
let paused=false;
let lastTime=0;

// 当たり判定縮小率
const hitboxShrink = 0.7;

// 安全描画
function safeDrawImage(img,x,y,w,h,color="#f0f"){
  try{
    if(img.complete && img.naturalWidth>0){ ctx.drawImage(img,x,y,w,h); }
    else { ctx.fillStyle=color; ctx.fillRect(x,y,w,h); }
  }catch(e){ ctx.fillStyle=color; ctx.fillRect(x,y,w,h); }
}

// リサイズ＆スケーリング
function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;

  // 表示サイズ（CSSピクセル基準）
  const displayWidth  = window.innerWidth;
  const displayHeight = window.innerHeight;

  // 内部解像度（実ピクセル）
  canvas.width  = displayWidth * dpr;
  canvas.height = displayHeight * dpr;

  // 見た目のサイズ
  canvas.style.width  = displayWidth + "px";
  canvas.style.height = displayHeight + "px";

  // スケールリセット → dpr反映
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);

  // プレイヤーサイズ・移動量は CSSピクセル基準
  playerSize = Math.min(displayWidth, displayHeight) * 0.15;
  moveStep   = Math.min(displayWidth, displayHeight) * 0.07;

  // プレイヤー初期位置（画面の左寄り・中央高さ）
  playerX = displayWidth * 0.2;
  playerY = displayHeight / 2;

  // 敵のサイズ調整（プレイヤーより小さめ）
  enemySize = playerSize * 0.8;
  
  // 移動後に画面外に出ないよう制限
  playerX = Math.max(0, Math.min(playerX, window.innerWidth - playerSize));
  playerY = Math.max(0, Math.min(playerY, window.innerHeight - playerSize));
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();


// ゲームリセット
function resetGame(){
  playerX = canvas.width * 0.4;
  playerY = canvas.height/2;
  enemies=[];
  score=0;
  gameOver=false;
  paused=false;
  lastTime=0;
}

// ゲームオーバー
function endGame(){
  gameOver=true;
  document.getElementById("gameOverScreen").style.display="flex";
  if(score>hiscore){ hiscore=score; localStorage.setItem("hiscore",hiscore); }
  document.getElementById("hiscoreText").innerText="HI SCORE: "+hiscore;
}

// 画面内制限
function clampPlayerPosition() {
  if(playerX < 0) playerX = 0;
  if(playerX + playerSize > canvas.width) playerX = canvas.width - playerSize;
  if(playerY < 0) playerY = 0;
  if(playerY + playerSize > canvas.height) playerY = canvas.height - playerSize;
}

// 更新
function update(dt){
  bgX -= 100*dt;
  if(bgX <= -canvas.width) bgX=0;

  playerTimer += dt;
  if(playerTimer > 0.2){ playerTimer = 0; playerFrame = (playerFrame+1)%2; }

  enemyTimer += dt;
  if(enemyTimer > 1.5){
    enemyTimer = 0;
    const img = enemyImgs[Math.floor(Math.random()*enemyImgs.length)];
    const enemySize = playerSize * 0.7; // 小さめに
    enemies.push({
      x: canvas.width,
      y: Math.random() * (canvas.height - enemySize),
      w: enemySize,
      h: enemySize,
      img: img
    });
  }

  enemies.forEach(e => e.x -= 200*dt);
  enemies = enemies.filter(e => e.x > -playerSize);

  // 当たり判定
  enemies.forEach(e=>{
    const hw = e.w * hitboxShrink;
    const hh = e.h * hitboxShrink;
    const hx = e.x + (e.w - hw)/2;
    const hy = e.y + (e.h - hh)/2;
    const pw = playerSize * hitboxShrink;
    const ph = playerSize * hitboxShrink;
    if(playerX < hx + hw &&
       playerX + pw > hx &&
       playerY < hy + hh &&
       playerY + ph > hy){
      endGame();
    }
  });

  score += Math.floor(100*dt);
  document.getElementById("score").innerText=score;
}

// 描画
function draw(){
  for(let i=0;i<bgImgs.length;i++){
    const img=bgImgs[i];
    const x=(i*canvas.width + bgX);
    safeDrawImage(img,x,0,canvas.width,canvas.height,"#88c");
    safeDrawImage(img,x+canvas.width*bgImgs.length,0,canvas.width,canvas.height,"#88c");
  }
  safeDrawImage(rabbilfFrames[playerFrame], playerX, playerY, playerSize, playerSize, "#ff0");
  enemies.forEach(e=> safeDrawImage(e.img, e.x, e.y, e.w, e.h, "#f00"));
}

// ループ
function loop(timestamp){
  if(lastTime===0) lastTime=timestamp;
  const dt=(timestamp-lastTime)/1000;
  lastTime=timestamp;
  if(!paused && !gameOver){
    update(dt);
    clampPlayerPosition(); // 画面外制限
    ctx.clearRect(0,0,canvas.width,canvas.height);
    draw();
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// 操作
window.addEventListener("keydown", e=>{
  if(e.key==="ArrowUp"||e.key==="w") playerY -= moveStep;
  if(e.key==="ArrowDown"||e.key==="s") playerY += moveStep;
  if(e.key==="ArrowLeft"||e.key==="a") playerX -= moveStep;
  if(e.key==="ArrowRight"||e.key==="d") playerX += moveStep;
  clampPlayerPosition();
});

// スマホ操作
canvas.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  const x = touch.clientX;
  const y = touch.clientY;

  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;

  const dx = x - centerX;
  const dy = y - centerY;

  if(Math.abs(dx) > Math.abs(dy)){
    // 横方向が強い → 左右
    if(dx < 0) playerX -= moveStep;
    else       playerX += moveStep;
  } else {
    // 縦方向が強い → 上下
    if(dy < 0) playerY -= moveStep;
    else       playerY += moveStep;
  }
});
// ボタン
document.getElementById("startBtn").onclick = ()=>{
  resetGame();
  document.getElementById("startScreen").style.display="none";
  bgm.volume = 0.2;
  bgm.play();
};
document.getElementById("retryBtn").onclick = ()=>{
  resetGame();
  document.getElementById("gameOverScreen").style.display="none";
};
document.getElementById("pauseBtn").onclick = ()=>{ paused=!paused; };
</script>
</body>
</html>
